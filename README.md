

# A Journey of Computer Science

Having studied Computer Science at University, I have often wondered about the question of 'What is a Computer Scientist?' However, more importantly, what I am really asking is 
'What should a Computer Scientist Know?' Looking for answer online gives some common topics, but also inconsistencies. For example, many cite cybersecurity as a crucial skill for computer scientists, alongside specific knowledge like fluency in [basic Unix][100]. However, I was not taught either of these during my degree. My university highly valued HCI and Machine Learning (as do I), which lead to a deeper focus on these topics in comparison to, for example, Cyber Security. This [post][101] provides many useful insights, many of which I agree with. It largely appears that this set of knowledge which a Computer Scientist must know will depend on the university, country, and time that we are asking these questions. There will, of course, be topics that every Computer Scientist should encounter: Boolean algebra, sorting algorithms, control-flow. Yet, we quickly reach a point of uncertainty: should I know how to create my own programming language? Should I be able to describe the halting problem in detail or be able to implement regular expressions through different finite automata? Part of the answer to this question of 'What should a Computer Scientist Know?' is clear: a lot of what you learn should be what you want to learn. This will likely align with your future goals, whether that be acquiring a new job, creating something cool, or perhaps simply pursuing knowledge for its own sake. 

I could write endlessly about this, but that is beside the point. This repository marks the journey I want to embark on to sharpen my technical skills, gain new knowledge, and—most importantly—have fun learning about computer science. I have divided this learning into a couple parts. First, there’s the "Fundamentals," which cover essential topics that I, like many others, believe are essential to the study of Computer Science. Next, we have the "Advanced" section, focusing on specialized topics that can be best understood after solidifying a foundation in the fundamentals. Lastly, there’s the "Specialist" section, which reflects my specific interests within Computer Science that I want to explore in depth. For example, I have a passion for exploring and visualizing data, so I’m eager to develop the skills necessary to hopefully one day become a proficient data analyst and data scientist!

This repository may be useful for anyone wanting to study computer science but unsure where to start, as many of the topics listed correspond to typical university modules. I recommend checking out Forrest Knight on YouTube for an well-structured approach to self-teaching a computer science degree, along with some excellent JavaScript videos. Of course, this repository will adapt and extend as I explore each course and section. Any code and development work I complete for these courses will be stored here as a personal record. 

Lastly, while this repository focuses on courses to build knowledge, it's important to remember that to know computer science, is to do computer science. If you’re looking to self-teach, these courses will be incredibly helpful, but working on your own personal projects will be equally, if not more, valuable. If you’re reading this and want to sharpen your cs skills too, good luck; I’m rooting for you.

# I - Fundamentals

###  0) History of Computer Science

###  1) System Architecture

| Courses | School | Duration (Hours) | Course Content|
|:--------------------------------------------------------------------------------|:-----------------------------:|:--------:|:------------------------------------------------------------------------------------------------------|
|[Build a Modern Computer from First Principles: From Nand to Tetris][1]          |Hebrew University of Jerusalem |43 Hours|Boolean Functions & Gate Logic, Integer Representation & the ALU, Memory, Machine Language, Modern Computer Architecture, Assemblers|
|[Build a Modern Computer from First Principles: From Nand to Tetris (Part II)][2]| Hebrew University of Jerusalem| 89 Hours | Machine Language, Stack Arithmetic, Program Control, High Level Languages, Compilers, Operating Systems


### 2) Principles of Programming & Software Development 
| Courses | School | Duration (Hours) | Course Content
|:---------------------------------------------------------------------------------|:-----------------------------:|:--------:|:------------------------------------------------------------------------------------------------------|
|[UBCx: Software Engineering: Introduction][10]|The University of British Colombia| 8 Weeks  | Software Processes, Specifications and Testing, High-Level Design, Lowl-Level Design, Code Construction, Information Security, Intellectual Property & Ethics |
|[Programming Languages, Part A][7]|University of Washington | 29 Hours | Variables, Functions, Datatypes, Recursion, Maps & Filters, Closures |
[Programming Languages, Part B][8] |University of Washington | 16 Hours | Racket Programming Language, Implementing Programming Languages using Interpreters, Static & Dynamic Typing
[Programming Languages, Part C][9] |University of Washington | 18 Hours | Ruby, OOP, Functional Programming, Sub-typing


### 3) Networking & Databases 
| Courses | School | Duration (Hours) | Course Content
|:---------------------------------------------------------------------------------|:-----------------------------:|:--------:|:-----------------------------------------------------------------------------------------------------------------|
|[Introduction to Databases][12]|Meta| 5 Weeks| Overview of Databases & Data, Structure of Relational Databases, SQL Introduction & CRUD Operations, Sorting & Filtering in SQL, Database Schema, Relational Database Design, Database Normalization|
[The Bits and Bytes of Computer Networking (Introduction to Networks)][11] | Google| 25 Hours | TCP/IP & OSI Model, Network Layer, Transport & Application Layers, Networking Services, Connecting to the Internet, Future of Networking

# II - Advanced

### 1) Advanced Algorithms

| Courses | School | Duration (Hours) | Course Content
|:---------------------------------------------------------------------------------|:-----------------------------:|:--------:|:-----------------------------------------------------------------------------------------------------------------|
| [Algorithms, Part 1][3]  | Princeton University | 54 Hours | Basic Analysis of Algorithms, Union-Find, Stacks & Queues, Elementary Sorts, Mergesort, Quicksort, Priority Queues, Elementary Symbol Tables, Balanced Search Trees & Geometric Applications, Hash Tables, Symbol Table Applications
| [Algorithms, Part 2][4] | Princeton University | 62 Hours | Undirected Graphs, Directed Graphs, Minimum Spanning Trees, Shortest Paths, Maximum Flow & Minimal Cut, Radix Sorts, Tries, Substring Search, Regular Expression, Data Compression, Reductions, Linear Programming, Intractibility|

### 2) Machine Learning
| Courses | School | Duration (Hours) | Course Content
|:---------------------------------------------------------------------------------|:-----------------------------:|:--------:|:-----------------------------------------------------------------------------------------------------------------|
|[Machine Learning Specialization, Part 1: Supervised ML: Regression & Classification ][16]| DeepLearning.AI | 33 Hours | Supervised vs Unsupervised Learning, Regression, Classification (Logisitic Regression) |
|[Machine Learning Specialization, Part 2: Advanced Learning Algorithms: Regression & Classification][17] | DeepLearning.AI | 34 Hours | Introduction to Neural Networks, Neural Network Training (ForwardPropagation & Backpropagation), Pipeline for developing an ML Model, Decision Trees|
|[Machine Learning Specialization, Part 3: Unsupervised Learning, Recommenders, Reinforcement Learning][18] | DeepLearning.AI | 27 Hours | Unsupervised Learning (K-Means Clustering), Recommender Systems, Introduction to Reinforcement Learning |

### 3) Theory of Computation
| Courses | School | Duration (Hours) | Course Content
|:---------------------------------------------------------------------------------|:-----------------------------:|:--------:|:-----------------------------------------------------------------------------------------------------------------|
| [Computer Science: Algorithms, Theory, and Machines][5]  | Princeton University | 20 Hours| Introduction to Theory of Computing, Turing Machines, Intractibility, A Computing Machine, Von Neumann Machines, Combinatorial Circuits, CPU|

Further topics to be added here include: HCI, Cryptography & Computer Security, Visual Computing.

# III - Specialist

### 1) Data Analyst (Python, SQL)
| Courses | School | Duration (Hours) | Course Content
|:---------------------------------------------------------------------------------|:-----------------------------:|:--------:|:-----------------------------------------------------------------------------------------------------------------|
| [Associate Data Analyst in SQL][19] | DataCamp | 39 Hours | SLQ Commands, Data Manipulation in SQL, PostGreSQL, Introduction to Statistics, Data-Driven Decision Making in SQL, Data Visualization, Data Communication
| [Data Analyst in Python][20] | DataCamp | 36 Hours | Python, Data Manipulation in Pandas, Statistics in Python, Data Visualization in Seaborn, Sampling, Hypothesis Testing |

# Additional Content
1) [Matt Might's - What Every Computer Science Major Should Know][100]
2) [HackerNews discussion on the topics every Computer Scientist should understand][101]

[1]: https://www.coursera.org/learn/build-a-computer
[2]: https://www.coursera.org/learn/nand2tetris2?irclickid=R9oWrV2sTxyKU4%3A2opRerW%3ApUkHSwRQVX1GL180&irgwc=1&utm_medium=partners&utm_source=impact&utm_campaign=1459666&utm_content=b2c
[3]: https://www.coursera.org/learn/algorithms-part1
[4]: https://www.coursera.org/learn/algorithms-part2
[5]: https://www.coursera.org/learn/cs-algorithms-theory-machines
[7]: https://www.coursera.org/learn/programming-languages
[8]: https://www.coursera.org/learn/programming-languages-part-b
[9]: https://www.coursera.org/learn/programming-languages-part-c
[10]: https://www.edx.org/course/software-engineering-introduction-ubcx-softeng1x
[11]: https://www.coursera.org/learn/computer-networking
[12]: https://www.coursera.org/learn/introduction-to-databases
[15]: https://news.ycombinator.com/item?id=20453241
[16]: https://www.coursera.org/learn/machine-learning?specialization=machine-learning-introduction
[17]: https://www.coursera.org/learn/advanced-learning-algorithms?specialization=machine-learning-introduction
[18]: https://www.coursera.org/learn/unsupervised-learning-recommenders-reinforcement-learning?specialization=machine-learning-introduction
[19]: https://app.datacamp.com/learn/career-tracks/associate-data-analyst-in-sql
[20]: https://app.datacamp.com/learn/career-tracks/data-analyst-with-python


[100]: https://matt.might.net/articles/what-cs-majors-should-know/#:~:text=There%20is%20no%20substitute%20for%20a%20solid%20understanding%20of%20computer,control%20units%2C%20caches%20and%20RAM.
[101]: https://news.ycombinator.com/item?id=20453241


